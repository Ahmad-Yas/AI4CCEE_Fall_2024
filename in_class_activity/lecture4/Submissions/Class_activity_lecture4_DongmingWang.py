# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V67hWCvq-s7fY_vFbH4aA076xq65hLVI
"""

# prompt: Load the data into a pandas DataFrame and display the first few rows to understand
# its structure

import pandas as pd

# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Display the first 5 rows of the DataFrame
print(data.head())

# prompt: Plot the scatter line raw sensor data (speed vs. time)

import matplotlib.pyplot as plt

# Assuming 'Time' and 'Speed' are the column names in your DataFrame
plt.scatter(data['Time'], data['WAVE-NE-Speed'])
plt.xlabel('Time')
plt.ylabel('Speed')
plt.title('Speed vs. Time')
plt.show()



# prompt: Define a static threshold (e.g., speed < 20 units). Count the number of minutes where
# the speed drops below this threshold

import pandas as pd
threshold = 20  # Define your speed threshold

# Assuming 'Time' is in a format that can be converted to minutes
# If it's not, you might need to adjust the code accordingly
data['Time'] = pd.to_datetime(data['Time'])  # Convert 'Time' to datetime objects if needed
data['Minute'] = data['Time'].dt.minute  # Extract the minute from the 'Time' column

# Count the number of minutes where speed is below the threshold
minutes_below_threshold = data[data['WAVE-NE-Speed'] < threshold]['Minute'].nunique()

print(f"Number of minutes with speed below {threshold}: {minutes_below_threshold}")

# prompt: select data for one month and Plot the scatter line raw sensor data (speed vs. time)

import pandas as pd
import matplotlib.pyplot as plt

# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Convert 'Time' column to datetime objects
data['Time'] = pd.to_datetime(data['Time'])

# Select data for a specific month (e.g., January 2023)
start_date = '2023-01-01'
end_date = '2023-01-31'
month_data = data[(data['Time'] >= start_date) & (data['Time'] <= end_date)]

# Plot the scatter line for the selected month
plt.figure(figsize=(12, 6))  # Adjust figure size as needed
plt.scatter(month_data['Time'], month_data['WAVE-NE-Speed'], s=10)  # s controls marker size
plt.xlabel('Time')
plt.ylabel('Speed')
plt.title('Speed vs. Time (January 2023)')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

data.describe()

# prompt: Plot the scatter line raw sensor data (speed vs. time) for first 1253 rows

import pandas as pd
import matplotlib.pyplot as plt
# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Select the first 1253 rows
first_1253_rows = data.iloc[:1253]

# Plot the scatter line for the selected rows
plt.figure(figsize=(12, 6))  # Adjust figure size as needed
plt.scatter(first_1253_rows['Time'], first_1253_rows['WAVE-NE-Speed'], s=10)  # s controls marker size
plt.xlabel('Time')
plt.ylabel('Speed')
plt.title('Speed vs. Time ')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

# prompt: Define a static threshold (e.g., speed < 60 units). Count the number of minutes where
# the speed drops below this threshold

import pandas as pd

# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Convert 'Time' column to datetime objects
data['Time'] = pd.to_datetime(data['Time'])

# Define the static threshold
threshold = 60

# Extract the minute from the 'Time' column
data['Minute'] = data['Time'].dt.minute

# Count the number of minutes where speed is below the threshold
minutes_below_threshold = data[data['WAVE-NE-Speed'] < threshold]['Minute'].nunique()

print(f"Number of minutes with speed below {threshold}: {minutes_below_threshold}")

# prompt: scatter plot where
# the speed drops below this threshold for first 1253 rows

import pandas as pd
import matplotlib.pyplot as plt

# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Select the first 1253 rows
first_1253_rows = data.iloc[:1253]

# Define the threshold
threshold = 60  # Adjust this threshold as needed

# Create a scatter plot with points below the threshold highlighted
plt.figure(figsize=(12, 6))
plt.scatter(first_1253_rows['Time'], first_1253_rows['WAVE-NE-Speed'], s=10, color='blue')
plt.scatter(first_1253_rows[first_1253_rows['WAVE-NE-Speed'] < threshold]['Time'],
            first_1253_rows[first_1253_rows['WAVE-NE-Speed'] < threshold]['WAVE-NE-Speed'],
            s=10, color='red')  # Highlight points below the threshold in red

plt.xlabel('Time')
plt.ylabel('Speed')
plt.title('Speed vs. Time ')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# prompt: Implement a 5-minute rolling average to smooth the sensor data of activity 0 for first 1253 rows

import pandas as pd
import matplotlib.pyplot as plt

# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Select the first 1253 rows
first_1253_rows = data.iloc[:1253]

# Calculate the 5-minute rolling average for 'WAVE-NE-Speed'
first_1253_rows['Rolling_Average_Speed'] = first_1253_rows['WAVE-NE-Speed'].rolling(window=5).mean()

# Plot the original and smoothed data
plt.figure(figsize=(12, 6))
plt.plot(first_1253_rows['Time'], first_1253_rows['WAVE-NE-Speed'], label='Original Speed')
plt.plot(first_1253_rows['Time'], first_1253_rows['Rolling_Average_Speed'], label='5-Minute Rolling Average')
plt.xlabel('Time')
plt.ylabel('Speed')
plt.title('Speed vs. Time (5-Minute Rolling Average)')
plt.xticks(rotation=45)
plt.legend()
plt.tight_layout()
plt.show()

# prompt: Check for missing data for first 1253 rows

import pandas as pd
# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Select the first 1253 rows
first_1253_rows = data.iloc[:1253]

# Check for missing data in the selected rows
missing_data = first_1253_rows.isnull().sum()

print("Missing data in the first 1253 rows:")
print(missing_data)

# prompt: Check for missing data for first 1253 rows,If missing values are present in the speed column, fill them using interpolation

import pandas as pd
import matplotlib.pyplot as plt
# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Select the first 1253 rows
first_1253_rows = data.iloc[:1253]

# Check for missing data in the 'WAVE-NE-Speed' column
missing_speed_data = first_1253_rows['WAVE-NE-Speed'].isnull().sum()

if missing_speed_data > 0:
  print(f"Found {missing_speed_data} missing values in the 'WAVE-NE-Speed' column.")

  # Fill missing values using linear interpolation
  first_1253_rows['WAVE-NE-Speed'] = first_1253_rows['WAVE-NE-Speed'].interpolate(method='linear')

  print("Missing values in 'WAVE-NE-Speed' filled using linear interpolation.")

else:
  print("No missing values found in the 'WAVE-NE-Speed' column.")

# You can now proceed with your analysis using the updated DataFrame
# For example, you can plot the data again to see the effect of interpolation:
# plt.plot(first_1253_rows['Time'], first_1253_rows['WAVE-NE-Speed'])
# plt.show()

# prompt: Check for and remove duplicate rows

import pandas as pd
# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Check for duplicate rows
duplicate_rows = data[data.duplicated()]

if not duplicate_rows.empty:
  print("Duplicate rows found:")
  print(duplicate_rows)

  # Remove duplicate rows (keeping the first occurrence)
  data = data.drop_duplicates()

  print("Duplicate rows removed.")

else:
  print("No duplicate rows found.")

# You can now proceed with your analysis using the updated DataFrame
# For example, you can check the shape of the DataFrame to see if rows were removed:
# print(data.shape)

# prompt: Remove any speed values that fall outside a reasonable range

import pandas as pd
# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Define a reasonable speed range (e.g., 0 to 100 mph)
min_speed = 0
max_speed = 100

# Remove rows with speed values outside the range
data = data[(data['WAVE-NE-Speed'] >= min_speed) & (data['WAVE-NE-Speed'] <= max_speed)]

# You can now proceed with your analysis using the updated DataFrame
# For example, you can check the shape of the DataFrame to see if rows were removed:
# print(data.shape)

# prompt: Plot the Cleaned Data for first 1253 rows

import pandas as pd
import matplotlib.pyplot as plt
# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Select the first 1253 rows
first_1253_rows = data.iloc[:1253]

# Plot the scatter line for the selected rows
plt.figure(figsize=(12, 6))  # Adjust figure size as needed
plt.scatter(first_1253_rows['Time'], first_1253_rows['WAVE-NE-Speed'], s=10)  # s controls marker size
plt.xlabel('Time')
plt.ylabel('Speed')
plt.title('Speed vs. Time (Cleaned Data - Time)')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

# prompt: Apply the Fast Fourier Transform (FFT) to previous data

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Select the first 1253 rows
first_1253_rows = data.iloc[:1253]

# Extract the 'WAVE-NE-Speed' column as a NumPy array
speed_data = first_1253_rows['WAVE-NE-Speed'].values

# Apply the FFT
fft_result = np.fft.fft(speed_data)

# Get the frequencies corresponding to the FFT results
frequencies = np.fft.fftfreq(len(speed_data))

# Plot the magnitude spectrum of the FFT
plt.figure(figsize=(12, 6))
plt.plot(frequencies, np.abs(fft_result))
plt.xlabel('Frequency (Hz)')
plt.ylabel('Magnitude')
plt.title('FFT of Speed Data')
plt.show()

! pip install pywavelets
import matplotlib.pyplot as plt
import numpy as np

import pywt

# use 'list' to get a list of all available 1d demo signals
signals = pywt.data.demo_signal('list')

subplots_per_fig = 5
signal_length = 1024
i_fig = 0
n_figures = int(np.ceil(len(signals)/subplots_per_fig))
for i_fig in range(n_figures):
    # Select a subset of functions for the current plot
    func_subset = signals[
        i_fig * subplots_per_fig:(i_fig + 1) * subplots_per_fig]

    # create a figure to hold this subset of the functions
    fig, axes = plt.subplots(subplots_per_fig, 1)
    axes = axes.ravel()
    for n, signal in enumerate(func_subset):
        if signal in ['Gabor', 'sineoneoverx']:
            # user cannot specify a length for these two
            x = pywt.data.demo_signal(signal)
        else:
            x = pywt.data.demo_signal(signal, signal_length)
        ax = axes[n]
        ax.plot(x.real)
        if signal == 'Gabor':
            # The Gabor signal is complex-valued
            ax.plot(x.imag)
            ax.legend(['Gabor (Re)', 'Gabor (Im)'], loc='upper left')
        else:
            ax.legend([signal, ], loc='upper left')
    # omit axes for any unused subplots
    for n in range(n + 1, len(axes)):
        axes[n].set_axis_off()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

import pywt

time, sst = pywt.data.nino()
dt = time[1] - time[0]

# Taken from http://nicolasfauchereau.github.io/climatecode/posts/wavelet-analysis-in-python/
wavelet = 'cmor1.5-1.0'
scales = np.arange(1, 128)

[cfs, frequencies] = pywt.cwt(sst, scales, wavelet, dt)
power = (abs(cfs)) ** 2

period = 1. / frequencies
levels = [0.0625, 0.125, 0.25, 0.5, 1, 2, 4, 8]
f, ax = plt.subplots(figsize=(15, 10))
ax.contourf(time, np.log2(period), np.log2(power), np.log2(levels),
            extend='both')

ax.set_title(f'Nino1+2 Wavelet Power Spectrum ({wavelet})')
ax.set_ylabel('Period (years)')
Yticks = 2 ** np.arange(np.ceil(np.log2(period.min())),
                        np.ceil(np.log2(period.max())))
ax.set_yticks(np.log2(Yticks))
ax.set_yticklabels(Yticks)
ax.invert_yaxis()
ylim = ax.get_ylim()
ax.set_ylim(ylim[0], -1)

plt.show()

# prompt: Apply a continuous wavelet transform (CWT) to the sensor data to visualize how the
# frequency content changes over time. Use wavelet = 'mexh'

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import pywt

# Assuming your data is in a CSV file named 'your_data.csv'
# Replace 'your_data.csv' with the actual file name and path if needed
data = pd.read_csv('/content/Wavetronix.csv')

# Select the first 1253 rows
first_1253_rows = data.iloc[:1253]

# Extract the 'WAVE-NE-Speed' column as a NumPy array
speed_data = first_1253_rows['WAVE-NE-Speed'].values

# Define the wavelet and scales
wavelet = 'mexh'  # You can try different wavelets like 'morl', 'gaus1', etc.
scales = np.arange(1, 128)

# Calculate the CWT
dt = 1  # Assuming a time step of 1 (adjust if needed)
coefficients, frequencies = pywt.cwt(speed_data, scales, wavelet, dt)

# Plot the CWT
plt.figure(figsize=(12, 6))
plt.imshow(np.abs(coefficients), extent=[0, len(speed_data), frequencies[-1], frequencies[0]], aspect='auto', cmap='viridis')
plt.xlabel('Time')
plt.ylabel('Frequency')
plt.title('Continuous Wavelet Transform (CWT) of Speed Data')
plt.colorbar(label='Wavelet Coefficient Magnitude')
plt.show()

# prompt: plot a scalogram (heatmap) of the wavelet coefficients.

import matplotlib.pyplot as plt

# Assuming you have already calculated the CWT coefficients (coefficients) and frequencies

plt.figure(figsize=(12, 6))
plt.imshow(abs(coefficients),
           extent=[0, len(speed_data), frequencies[-1], frequencies[0]],
           aspect='auto',
           cmap='viridis',
           interpolation='bilinear')
plt.xlabel('Time')
plt.ylabel('Scale')
plt.title('Scalogram (Wavelet Transform)')
plt.colorbar(label='Wavelet Coefficient Magnitude')
plt.show()

# prompt: Install requests, pillow, and pywt in your colab environment.

!pip install requests pillow pywt

# prompt: Display the image

import matplotlib.pyplot as plt
import matplotlib.image as mpimg

# Replace 'image_path' with the actual path to your image file
image_path = '/content/2018-06-30-19-05.jpg'

img = mpimg.imread(image_path)
plt.imshow(img)
plt.axis('off')  # Turn off axis labels and ticks
plt.show()

# prompt: Convert image to np array

import numpy as np

# Assuming 'img' is your image loaded using matplotlib.image.imread
image_array = np.array(img)

print(image_array.shape)  # Print the shape of the NumPy array

import matplotlib.pyplot as plt
import pywt

# Perform 2D Discrete Wavelet Transform (DWT) using the Haar wavelet
coeffs = pywt.dwt2(image_array, 'haar')

# coeffs will contain the approximation and detail coefficients
# (cA, (cH, cV, cD))
cA, (cH, cV, cD) = coeffs

# Calculate the mean across the third dimension for each coefficient array
cA = np.mean(cA, axis=2)
cH = np.mean(cH, axis=2)
cV = np.mean(cV, axis=2)
cD = np.mean(cD, axis=2)

# You can now analyze or visualize the wavelet coefficients
# For example, you can display the approximation coefficients:
plt.imshow(cA, cmap='gray')
plt.title('Approximation Coefficients (cA)')
plt.show()

# Or display the horizontal detail coefficients:
plt.imshow(cH, cmap='gray')
plt.title('Horizontal Detail Coefficients (cH)')
plt.show()

# Similarly, you can display cV (vertical detail) and cD (diagonal detail)

import matplotlib.pyplot as plt
import pywt

# Perform 2D Discrete Wavelet Transform (DWT) using the Haar wavelet
coeffs = pywt.dwt2(image_array, 'haar')

# coeffs will contain the approximation and detail coefficients
# (cA, (cH, cV, cD))
cA, (cH, cV, cD) = coeffs

# Calculate the mean across the third dimension for each coefficient array
cA = np.mean(cA, axis=2)
cH = np.mean(cH, axis=2)
cV = np.mean(cV, axis=2)
cD = np.mean(cD, axis=2)

# Display the approximation coefficients (LL):
plt.imshow(cA, cmap='gray')
plt.title('Approximation Coefficients (LL)')
plt.show()

# Display the horizontal detail coefficients (LH):
plt.imshow(cH, cmap='gray')
plt.title('Horizontal Detail Coefficients (LH)')
plt.show()

# Display the vertical detail coefficients (HL):
plt.imshow(cV, cmap='gray')
plt.title('Vertical Detail Coefficients (HL)')
plt.show()

# Display the diagonal detail coefficients (HH):
plt.imshow(cD, cmap='gray')
plt.title('Diagonal Detail Coefficients (HH)')
plt.show()